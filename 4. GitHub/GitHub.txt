âœ… Monitoring & Debugging GitHub Actions
ðŸ”¹ View workflow logs

Navigate to GitHub Repository â†’ Actions â†’ Select Workflow â†’ View Logs
Use echo "::debug::message" for debugging.
ðŸ”¹ Enable Debug Logging
Set ACTIONS_RUNNER_DEBUG=true for detailed logs

jobs:
  debug:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Debugging GitHub Actions"
        env:
          ACTIONS_RUNNER_DEBUG: "true"

ðŸ”¹ RBAC Components in GitHub
1ï¸âƒ£ Organization-Level RBAC
-> At the organization level, GitHub provides these roles:
Role	Description
Owner	Full access, can manage repositories, teams, billing, and security.
Member	Standard role with limited access based on repository/team permissions.

ðŸ”¹ Assigning Organization Roles:
-- Go to Organization Settings â†’ People â†’ Manage Role.

2ï¸âƒ£ Repository-Level RBAC
-> At the repository level, GitHub offers fine-grained permissions:
-> Role	Permissions
Admin	Full control over repo, including settings & access management.
Maintain	Manage repo without admin settings (e.g., branch protection).
Write	Push code, manage issues, and approve PRs.
Triage	Manage issues, PRs, and discussions, but cannot push code.
Read	View code, clone repo, and comment on issues & PRs.

-> Assigning Repository Roles:
Go to Repo Settings â†’ Manage Access â†’ Invite Team/User â†’ Assign Role.

3ï¸âƒ£ Team-Based RBAC (For Organizations)
-> GitHub Teams allow grouping multiple users and managing access centrally.
-> Teams can be assigned repo-level permissions (e.g., "Developers" team gets Write access).
ðŸ”¹ Managing Team Permissions:
-- Go to Organization Settings â†’ Teams â†’ Select Team â†’ Manage Access.

4ï¸âƒ£ Fine-Grained Personal Access Token (PAT) Permissions
-> Instead of broad OAuth scopes, GitHub now allows fine-grained PATs where you can define specific repo access (read/write).
Example:
-- Read access to issues
-- Write access to workflows

ðŸ”¹ How RBAC is Enforced in GitHub Actions & API?
1ï¸âƒ£ RBAC in GitHub Actions (Rulesets & Protected Branches)
-- You can restrict workflows from running without specific approvals.
-- Branch protection ensures that only authorized users can push to main.
------------------------------------------------------------------------------------------
Difference between Jenkins and GitHub Actions: 

					Jenkins				GitHub Actions
Software model			Open source				Open source
Hosting				On-premise and cloud-based		On-premise and cloud-based
Supported OS			Linux/Windows/MacOS			Linux/Windows/MacOS
Ease of use and Setup		Medium					Easy to use
Installation			Required				Not required
Scalability			Highly scalable				Limited by GitHubâ€™s infrastructure
Control		Doesnâ€™t provide full control over CI\CD pipelines	Full control over CI\CD pipelines
Paid plan details      Free to use, requires a dedicated administrator	Both free and paid plans with varying features and usage limits.

** Pricing Considerations
-- GitHub Actions offers a generous free tier for both public and private repositories. This makes it an attractive choice, especially for smaller teams or open-source projects with budget constraints.
-- Jenkins is an open-source tool, meaning itâ€™s free to use, but organizations need to consider infrastructure costs for hosting and maintaining Jenkins servers, potentially impacting the overall cost comparison.

** User Interface:
-- The Jenkins UI is not user-friendly and can be overwhelming for beginners. It requires a lot of configuration and customization to set up even the simplest of pipelines. 
-- GitHub Actions, on the other hand, has a modern and intuitive UI that is easy to navigate. It provides a visual representation of workflows and simplifies pipeline creation and management.

** Ease of Use:
-- Jenkins requires a lot of setup and configuration before it can be used. It also has a steep learning curve due to its complexity.
-- GitHub Actions is very easy to set up and use. It has a simple YAML syntax that is easy to read and understand. It also provides pre-built templates that can be used to quickly create pipelines.

** Integration Capabilities
-- Jenkins has a long-standing reputation for its extensive integration capabilities. Its vast plugin ecosystem allows seamless integration with a wide array of third-party services and tools. 
	-- Jenkins, on the other hand, requires plugins and additional configuration to integrate with GitHub.
-- GitHub Actions, while growing, might have slightly fewer integrations out of the box, but it offers a solid foundation for CI/CD workflows.

** Scalability
-- GitHub Actions handles scalability well, particularly with its matrix builds feature that allows parallel testing across different configurations.
-- Jenkins has been a go-to choice for large enterprises with intricate scaling requirements, thanks to its distributed build capabilities and extensive plugin support.

** Organizational Preference
-- Jenkins is often preferred in large enterprises with established CI/CD processes. It is best suited for projects with intricate build and deployment requirements. 
-- GitHub Actions however, is particularly favoured by smaller teams for its simplicity and direct integration with repositories. Organizations heavily relying on GitHub for version control may find GitHub Actions more seamless.

** Community:
-- Support Jenkins has been around for a long time and has a large and active community. It has a vast repository of plugins that can be used to extend its functionality. 
-- GitHub Actions, although relatively new, has quickly gained traction and has a growing community of developers. It also has a library of pre-built actions that can be used to quickly create workflows.

** Jenkins offers extensibility and customization, while GitHub Actions provides seamless integration and simplicity. As organizations increasingly migrate to cloud-based solutions, GitHub Actions is gaining traction, but the choice ultimately depends on the specific requirements and constraints of your development environment.


--------------------------------------------------------------------------
âœ…1. What is GitHub?
-> GitHub is a platform that allows users to store, create, change, and collaborate on files and code. It's used by programmers and developers to manage projects, share progress, and work on open-source projects.
 

âœ…2. GitHub Actions: GitHub Actions is a platform that automates software development workflows, including builds, tests, and deployments. 
-- It's a continuous integration and continuous delivery (CI/CD) tool that allows you to: Create custom CI workflows, Speed up application development, Run arbitrary code on a repository when an event occurs, and Combine actions in a customized workflow. 

-- GitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure.

-- GitHub Actions is a CI/CD & workflow automation tool integrated into GitHub that enables event-driven automation for repositories. It allows you to:
1. Automate testing, building, and deploying applications.
2. Orchestrate workflows for infrastructure as code (Terraform, Ansible, Kubernetes, AWS, Azure, GCP).
3. Integrate security scanning and compliance checks into the pipeline.
4. Run jobs on GitHub-hosted or self-hosted runners.

ðŸ“Œ Why GitHub Actions?
âœ”ï¸ Native GitHub Integration (No need for external CI/CD tools like Jenkins).
âœ”ï¸ Event-Driven (Triggers based on push, PR, schedule, etc.).
âœ”ï¸ Supports Docker & Multi-Platform Builds.
âœ”ï¸ Parallel & Matrix Builds for optimizing pipelines.
âœ”ï¸ Free for Open Source & cost-effective for private repositories.


-----------------------------------------------------------------------
âœ… The components of GitHub Actions: 
-> GitHub Actions workflow to be triggered when an event occurs in your repository, such as a pull request being opened or an issue being created. 
** Your workflow contains one or more jobs which can run in sequential order or in parallel. 
** Each job will run inside its own virtual machine runner, or inside a container, and has one or more steps that either run a script that you define or run an action, which is a reusable extension that can simplify your workflow.

ðŸ”¹ Workflows: A workflow is a configurable automated process that will run one or more jobs. 
-- Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.

-- Workflows are defined in the .github/workflows directory in a repository. A repository can have multiple workflows, each which can perform a different set of tasks such as:
	a. Building and testing pull requests.
	b. Deploying your application every time a release is created.
	c. Adding a label whenever a new issue is opened.
** You can reference a workflow within another workflow. For more information, see "Reusing workflows."


ðŸ”¹ Events: (push, pull_request, schedule, Manual Triggers)
-- An event is a specific activity in a repository that triggers a workflow run. 
-- For example, an activity can originate from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository. 
-- You can also trigger a workflow to run on a "schedule", by "posting to a REST API", or manually.
-- In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. (Re-Enable: GitHub - Actions - Select your workflow - Enable workflow)

-- This example triggers the workflow every day at 5:30 and 17:30 UTC:
on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'

-- Cron syntax has five fields separated by a space, and each field represents a unit of time.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ minute (0 - 59)
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ hour (0 - 23)
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of the month (1 - 31)
â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ month (1 - 12 or JAN-DEC)
â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of the week (0 - 6 or SUN-SAT)
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚
* * * * *

ðŸ”¹ Jobs: A job is a set of steps in a workflow that is executed on the same runner. Each step is either a shell script that will be executed, or an action that will be run. 
-- Steps are executed in order and are dependent on each other. Since each step is executed on the same runner, you can share data from one step to another. 
-- For example, you can have a step that builds your application followed by a step that tests the application that was built.

-- You can configure a job's dependencies with other jobs; by default, jobs have no dependencies and run in parallel. 
-- When a job takes a dependency on another job, it waits for the dependent job to complete before running.

-- For example, you might configure multiple build jobs for different architectures without any job dependencies and a packaging job that depends on those builds. 
-- The build jobs run in parallel, and once they complete successfully, the packaging job runs.


ðŸ”¹ Step â†’ A command or action executed in a job.

ðŸ”¹ Actions: An action is a custom application for the GitHub Actions platform that performs a complex but frequently repeated task. 
-- Use an action to help reduce the amount of repetitive code that you write in your workflow files. 
-- An action can pull your Git repository from GitHub, set up the correct toolchain for your build environment, or set up the authentication to your cloud provider.


ðŸ”¹ Runners: A runner is a server that runs your workflows when they're triggered. 
-- Each runner can run a single job at a time. 
-- GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run your workflows. Each workflow run executes in a fresh, newly-provisioned virtual machine.

-- GitHub also offers larger runners, which are available in larger configurations.

-- If you need a different operating system or require a specific hardware configuration, you can host your own runners.

-- For more information about self-hosted runners, see "Hosting your own runners."
-- Self-hosted runners: A self-hosted runner is a system that you deploy and manage to execute jobs from GitHub Actions on GitHub.com.

-- A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.

---------------------------------------------------------------------------
** GitHub's architecture:
-- It is a sophisticated and highly scalable system designed to support a wide range of development activities. Its architecture consists of various components and services that work together to provide functionalities like version control, issue tracking, continuous integration/continuous deployment (CI/CD), and more.

Hereâ€™s an overview of GitHubâ€™s architecture:

1. Web Interface
	a. Frontend: GitHubâ€™s web interface is built using modern web technologies like HTML, CSS, and JavaScript. It provides users with access to repositories, issues, pull requests, and other GitHub features through a user-friendly interface.
	b. APIs: GitHub offers RESTful and GraphQL APIs for programmatic access to repositories, issues, pull requests, and other resources.

2. Git Repositories
-- Git Database: At the core of GitHub is the Git database, which stores the actual source code, commits, branches, and tags. Git repositories are distributed and use a distributed version control system (DVCS) model.

3. Database Systems
-- Primary Databases: GitHub uses a combination of SQL (PostgreSQL) and NoSQL (Cassandra) databases to handle different types of data. 
   -- PostgreSQL is used for transactional data and relational data, while Cassandra is used for scalable and high-throughput data needs.
-- Caching: GitHub employs caching systems like Redis to speed up data retrieval and reduce database load.

4. Search and Indexing
-- Elasticsearch: GitHub uses Elasticsearch to provide powerful search capabilities across repositories, issues, pull requests, and other resources.
-- Indexing: Data indexing is crucial for efficient search and retrieval.

5. Continuous Integration/Continuous Deployment (CI/CD)
-- GitHub Actions: GitHub Actions is an integrated CI/CD service that allows users to automate workflows directly within GitHub. Actions can be used to build, test, and deploy code based on various triggers.
-- Runners: GitHub Actions uses both hosted and self-hosted runners to execute jobs defined in workflow YAML files.

6. Authentication and Authorization
-- OAuth and Personal Access Tokens: GitHub supports OAuth for third-party application integration and Personal Access Tokens (PATs) for authentication and authorization.
-- SAML and Single Sign-On (SSO): For enterprise accounts, GitHub integrates with SAML and SSO for user authentication and management.

7. Infrastructure and Deployment
-- Microservices Architecture: GitHub uses a microservices architecture to manage different functionalities and services. Each microservice handles a specific aspect of the platform.
-- Load Balancers: Load balancers distribute incoming traffic across multiple servers to ensure high availability and reliability.
-- Content Delivery Network (CDN): GitHub uses CDNs to deliver static assets (like images, CSS, and JavaScript) quickly to users around the world.

8. Monitoring and Logging
-- Monitoring: GitHub employs various monitoring tools and practices to track the performance and health of its services.
-- Logging: Centralized logging is used to collect and analyze logs for troubleshooting and performance monitoring.


---------------------------------------------------------------------------
** Differences between GitHub-hosted and self-hosted runners
-- GitHub-hosted runners offer a quicker, simpler way to run your workflows, while self-hosted runners are a highly configurable way to run workflows in your own custom environment.

1. GitHub-hosted runners:
# Receive automatic updates for the operating system, preinstalled packages and tools, and the self-hosted runner application.
# Are managed and maintained by GitHub.
# Provide a clean instance for every job execution.
# Use free minutes on your GitHub plan, with per-minute rates applied after surpassing the free minutes.

2. Self-hosted runners:
# Receive automatic updates for the self-hosted runner application only, though you may disable automatic updates of the runner. 
-- For more information about controlling runner software updates on self-hosted runners, see "Autoscaling with self-hosted runners." You are responsible for updating the operating system and all other software.
# Can use cloud services or local machines that you already pay for.
# Are customizable to your hardware, operating system, software, and security requirements.
# Don't need to have a clean instance for every job execution.
# Are free to use with GitHub Actions, but you are responsible for the cost of maintaining your runner machines.

** Setting up Self-Hosted Runners:
-> Organization level self-hosted runners:
Step1: Go to organization - Actions - Runner Groups - New Runner
Step2: New Self-Hosted runner - Select Linux, X64 ->
 
Run below commands on your EC2 Machine:
1. Download
-- We recommend configuring the runner under "\actions-runner". 
-- This will help avoid issues related to service identity folder permissions and long path restrictions on Windows.
 
# Create a folder under the drive root
$ mkdir actions-runner; cd actions-runner
# Download the latest runner package
$ Invoke-WebRequest -Uri https://github.com/actions/runner/releases/download/v2.321.0/actions-runner-win-x64-2.321.0.zip -OutFile actions-runner-win-x64-2.321.0.zip
# Optional: Validate the hash
$ if((Get-FileHash -Path actions-runner-win-x64-2.321.0.zip -Algorithm SHA256).Hash.ToUpper() -ne '88d754da46f4053aec9007d172020c1b75ab2e2049c08aef759b643316580bbc'.ToUpper()){ throw 'Computed checksum did not match' }
# Extract the installer
$ Add-Type -AssemblyName System.IO.Compression.FileSystem ; [System.IO.Compression.ZipFile]::ExtractToDirectory("$PWD/actions-runner-win-x64-2.321.0.zip", "$PWD")
 
2. Configure
# Create the runner and start the configuration experience
$ ./config.cmd --url https://github.com/Demo-Project-12345 --token A4QDRRRRK734HYIAOQCPW3LHSTLLE
# Run it!
$ ./run.cmd
 
3. Using your self-hosted runner
# Use this YAML in your workflow file for each job
runs-on: self-hosted

--------------------------------------------------------------------------
âœ… Communication between self-hosted runners and GitHub:
--------------------------------------------------------
-- The self-hosted runner connects to GitHub to receive job assignments and to download new versions of the runner application. 
-- The self-hosted runner uses an "HTTPS long poll" that opens a connection to GitHub for 50 seconds, and if no response is received, it then times out and creates a new long poll. 
-- The application must be running on the machine to accept and run GitHub Actions jobs.

-- The connection between self-hosted runners and GitHub is over HTTPS (port 443).
-- Since the self-hosted runner opens a connection to GitHub.com, you do not need to allow GitHub to make inbound connections to your self-hosted runner.
-- Self-hosted runners send heartbeat signals to GitHub to indicate that they are active and available.
-- When you add a self-hosted runner to your GitHub repository or organization, it registers itself with GitHub. 
-- This involves:
	@ Token Exchange: The runner obtains a registration token from GitHub during the setup process.
	@ Runner Configuration: The runner is configured to connect to GitHub using this token.
-- You must ensure that the machine has the appropriate network access with at least 70 kilobits per second upload and download speed to communicate with the GitHub hosts listed below. 
-- Some hosts are required for essential runner operations, while other hosts are only required for certain functionality.
-- You can use the REST API to get meta information about GitHub, including the IP addresses of GitHub services. 
-- For more information about the domains and IP addresses used, see "REST API endpoints for meta data."


** Self-hosted runner security
-- We recommend that you only use self-hosted runners with private repositories. 
-- This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.

-- This is not an issue with GitHub-hosted runners because each GitHub-hosted runner is always a clean isolated virtual machine, and it is destroyed at the end of the job execution.

-- Untrusted workflows running on your self-hosted runner pose significant security risks for your machine and network environment, especially if your machine persists its environment between jobs. Some of the risks include:
	* Malicious programs running on the machine.
	* Escaping the machine's runner sandbox.
	* Exposing access to the machine's network environment.
	* Persisting unwanted or dangerous data on the machine.

----------------------------------------------------------------------
âœ… Reusing workflows: A workflow that uses another workflow is referred to as a "caller" workflow. The reusable workflow is a "called" workflow.
->  One caller workflow can use multiple called workflows. Each called workflow is referenced in a single line.
-- Reusable workflows and composite actions both help you to avoid duplication. Whereas reusable workflows allow you to reuse an entire workflow, with multiple jobs and steps, composite actions combine multiple steps that you can then run within a job step, just like any other action. For more information, see "Avoiding duplication."

** Access to reusable workflows:  A reusable workflow can be used by another workflow if any of the following is true:
	a. Both workflows are in the same repository.
	b. The called workflow is stored in a public repository, and your organization allows you to use public reusable workflows.
	c. The called workflow is stored in a private repository and the settings for that repository allow it to be accessed. 
	--- For more information, see "Sharing actions and workflows with your organization" and "Sharing actions and workflows from your private repository."


** Limitations
1. You can connect up to four levels of workflows. For more information, see "Nesting reusable workflows."
2. You can call a maximum of 20 unique reusable workflows from a single workflow file. This limit includes any trees of nested reusable workflows that may be called starting from your top-level caller workflow file.
-- For example, top-level-caller-workflow.yml â†’ called-workflow-1.yml â†’ called-workflow-2.yml counts as 2 reusable workflows.
3. Any environment variables set in an env context defined at the workflow level in the caller workflow are not propagated to the called workflow. 
4. Similarly, environment variables set in the env context, defined in the called workflow, are not accessible in the env context of the caller workflow. Instead, you must use outputs of the reusable workflow. 
5. To reuse variables in multiple workflows, set them at the organization, repository, or environment levels and reference them using the vars context. 
6. Reusable workflows are called directly within a job, and not from within a job step. You cannot, therefore, use GITHUB_ENV to pass values to job steps in the caller workflow.


** Calling a reusable workflow
-- You call a reusable workflow by using the uses keyword. 
-- Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps.

jobs.<job_id>.uses

-- You reference reusable workflow files using one of the following syntaxes:

	{owner}/{repo}/.github/workflows/{filename}@{ref} for reusable workflows in public and private repositories.
	./.github/workflows/{filename} for reusable workflows in the same repository.

** You can call multiple workflows, referencing each in a separate job.
jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1


----------------------------------------------------------------------------------
âœ… Passing inputs and secrets to a reusable workflow
-- To pass named inputs to a called workflow, use the "with" keyword in a job. 
-- Use the "secrets" keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).

jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      envPAT: ${{ secrets.envPAT }}

-- Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.

jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit


** Using a matrix strategy with a reusable workflow
Jobs using the matrix strategy can call a reusable workflow.
-- A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to pass different inputs to a reusable workflow. For more information about matrices, see "Running variations of jobs in a workflow."
-- This example job below calls a reusable workflow and references the matrix context by defining the variable target with the values [dev, stage, prod]. It will run three jobs, one for each value in the variable.

YAML
jobs:
  ReuseableMatrixJobForDeployment:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: octocat/octo-repo/.github/workflows/deployment.yml@main
    with:
      target: ${{ matrix.target }}


---------------------------------------------------------------------------
Q. The errors or bugs in GitHub and GitHub actions and how to troubleshoot it?
-> Common Errors in GitHub
1. Authentication Issues
Error: â€œPermission deniedâ€ or â€œAuthentication failed.â€
-> Troubleshooting:
-- Verify Credentials: Ensure your SSH keys or personal access tokens (PAT) are correctly configured.
-- Token Scope: Make sure your PAT has the correct permissions.
-- SSH Configuration: Check your SSH key settings in your GitHub account and ensure your local SSH configuration is correct.
-- Cache Issues: Clear your credential cache or try using the git credential helper.

2. Repository Access Issues
Error: â€œRepository not foundâ€ or â€œYou donâ€™t have permission.â€
-> Troubleshooting:
-- Check Repository URL: Ensure the URL youâ€™re using is correct.
-- Permissions: Verify that you have the necessary access rights to the repository.
-- Organization Settings: For organization-owned repositories, ensure that the repository visibility and membership are configured properly.

3 Merge Conflicts
Error: Conflicts when merging branches.
-> Troubleshooting:
-- Resolve Conflicts: Manually resolve conflicts in your local repository and commit the changes.
-- Rebase: Alternatively, you can rebase your branch on top of the target branch to resolve conflicts.

4. File Size Limits
Error: â€œFile size exceeds the maximum allowed size.â€
-> Troubleshooting:
-- Git LFS: Use Git Large File Storage (LFS) for managing large files.
-- Check File Size: Avoid committing files that exceed GitHubâ€™s size limits.

-- Common Errors in GitHub Actions
1. . Workflow Failures
Error: â€œWorkflow run failedâ€ or specific step failures.
-> Troubleshooting:
-- Check Logs: Review the logs provided by GitHub Actions to identify where the failure occurred.
-- Syntax Errors: Verify the syntax of your workflow YAML files.
-- Action Versions: Ensure that youâ€™re using compatible versions of actions.
-- Secrets and Environment Variables: Make sure that required secrets and environment variables are correctly set.

2. Action Not Found
Error: â€œAction not foundâ€ or â€œInvalid action.â€
-> Troubleshooting:
-- Action Repository: Ensure the actionâ€™s repository is available and the URL is correct.
-- Version: Verify that youâ€™re using a valid version of the action.

3. Quota Limits
Error: â€œUsage limits exceededâ€ or similar messages.
-> Troubleshooting:
-- Check Usage: Monitor your GitHub Actions usage and limits in the GitHub billing and usage section.
-- Optimize Workflows: Review and optimize your workflows to reduce unnecessary runs or use caching.

4. Cache Issues
Error: â€œCache missâ€ or outdated cached data.
-> Troubleshooting:
-- Invalidate Cache: Use cache keys to ensure that the cache is updated correctly or manually clear the cache if necessary.
-- Check Cache Key: Ensure your cache key patterns are correctly defined.


---------------------------------------------------------------------------
** Basic overview and example of how to create a GitHub Actions YAML pipeline:

Basic Structure of a GitHub Actions Workflow
1. name: The name of your workflow. This is optional but helps to identify the workflow in the GitHub Actions UI.
2. on: Specifies the events that will trigger the workflow. Common triggers include push, pull_request, schedule, and workflow_dispatch.
3. jobs: Defines the jobs that make up the workflow. Each job runs in a separate runner and can have steps that specify the actions to be performed.
4. steps: A sequence of tasks within a job. Steps run in the order they are defined and can include actions or commands.
5. runs-on: Specifies the type of runner that will execute the job. Common options include ubuntu-latest, windows-latest, or macos-latest

name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_call:
    inputs:
      db_database_name: 
        required: true
        type: string
        description: DB name

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'
      - run: npm install
      - run: npm run build

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '14'
      - run: npm test

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v3
      - run: deploy.sh


--------------------------------------------------------------------
Q. Tell me something about Continuous Integration, Continuous Delivery, and Continuous Deployment (CI , CD)?
-> Continuous Integration: A software development process where the changes made to software are integrated into the main code as and when a patch is ready so that the software will be always ready to be - built, tested, deployed, monitored - continuously.
-> It is the integration btw SCM (Source Code Management) to jenkins, whenever someone commits code into SCM jenkins will pick the latest code into pipeline and start building it. The process will be continous with the help of github webhook.

*  webhook: A webhook is an HTTP-based callback function that allows lightweight, event-driven communication between 2 application 
         programming interfaces (APIs).
*  API: API makes Jenkins even easier to use by providing an easy to use conventional python interface.

** Continuous Delivery: This is a software Development Process where the continuously integrated (CI) changes will be tested & deployed continuously into a specific environment, generally through a manual release process, after all the quality checks are successful.
-> Once the artifact is build and deployed into UAT(User Acceptance Testing) or QA(Quality Assurance) servers, will to testing of the application on QA servers.
                                                                                               
** Continuous Deployment: A software Development practice where the continuously integrated (CI) changes are deployed automatically into the target environment after all the quality checks are successful.
-> Once testing is done, we deploy the application into prod servers where end user is using the application.

Based on the level of automation, the above three paradigms can be better represented as below -

CODE -> BUILD -> INTEGRATE -> RELEASE -> DEPLOY
<-CONT INTGn->
<- -   CONTINUOUS DELIVERY  - ->
<- - - - -    CONTINUOUS DEPLOYMENT   - - - ->

-----------------------------------------------------------------------------------------
âœ… 5. Security Best Practices in GitHub Actions
ðŸš¨ To prevent security risks, follow these best practices:
âœ”ï¸ Use secrets.GITHUB_TOKEN instead of plaintext credentials.
âœ”ï¸ Use dependency scanning & security tools like Snyk.
âœ”ï¸ Restrict access using branch protection rules.
âœ”ï¸ Run workflows with minimal permissions (permissions: read-all).
âœ”ï¸ Avoid using unverified third-party actions (use GitHub Marketplace).

permissions:
  contents: read
  issues: none
  actions: write

Q. How to secure GitHub actions?
-- Securing GitHub Actions is crucial to protect your code, workflows, and infrastructure from potential threats and unauthorized access. Here are some best practices and strategies to ensure the security of your GitHub Actions workflows:

1. Manage Secrets Securely
-- Use GitHub Secrets: Store sensitive data such as API keys, passwords, and tokens in GitHub Secrets. Avoid hardcoding secrets directly into your workflow files. Access secrets using the ${{ secrets.SECRET_NAME }} syntax.
-- Limit Secret Scope: Use repository or organization-level secrets only where necessary. Consider using environment-specific secrets for different deployment environments (e.g., development, staging, production).
	
2. Secure Workflow Files
-- Limit Access: Restrict access to workflow files by setting appropriate repository permissions. Only allow trusted users to modify workflow files.
-- Review and Audit: Regularly review workflow YAML files for security vulnerabilities and ensure that they follow best practices.

3. Use Least Privilege Principle
-- Restrict Permissions: Configure GitHub Actions workflows to use the least privilege principle. For example, if a workflow does not need to push code, avoid giving it write access to the repository.
-- Role-Based Access Control: Use GitHubâ€™s role-based access control features to grant permissions based on the role of each user or team within your organization.

4. Secure Self-Hosted Runners
-- Isolate Runners: Run self-hosted runners in isolated environments or containers to prevent unauthorized access and limit the impact of potential security breaches.
-- Update Regularly: Keep self-hosted runners up to date with the latest security patches and updates.
-- Limit Network Access: Restrict network access for self-hosted runners to only necessary endpoints. Use firewalls or security groups to limit exposure.

5. Review and Control Third-Party Actions
-- Use Trusted Actions: Only use actions from trusted sources and review the code of third-party actions when possible. Verify the security and reliability of actions before adding them to your workflows.
-- Monitor Dependencies: Regularly update actions and dependencies to address security vulnerabilities and ensure compatibility with GitHub Actions.

6. Monitor and Log Activity
-- Enable Logging: GitHub Actions automatically logs workflow runs. Review logs to detect and investigate suspicious or unexpected behavior.
-- Set Up Alerts: Configure alerts and notifications for workflow failures, unauthorized access attempts, or other anomalies.

7. Use Workflow Restrictions
-- Restrict Workflow Triggers: Control when workflows are triggered to reduce the risk of unauthorized or malicious activity. For example, restrict workflow triggers to specific branches or events.

yaml
Copy code
on:
  push:
    branches:
      - main

-- Require Pull Request Reviews: Configure branch protection rules to require pull request reviews before merging changes. This helps ensure that workflows are reviewed and approved by authorized team members.

8. Secure Workflow Artifacts
-- Protect Artifacts: Use permissions and access controls to protect artifacts produced by workflows. Avoid exposing sensitive information in artifacts.
-- Limit Artifact Retention: Configure artifact retention settings to limit the duration that artifacts are stored and reduce the risk of leaking sensitive data.

9. Implement Continuous Security Practices
-- Automate Security Checks: Integrate security tools and practices into your workflows, such as static code analysis, vulnerability scanning, and dependency checks.
-- Regular Audits: Conduct regular security audits and reviews of your GitHub Actions configurations and workflows to identify and address potential security issues.

10. Educate and Train Teams
-- Security Training: Provide security training and awareness for your development teams to help them understand and implement security best practices in their workflows.
-- Documentation: Maintain clear documentation on the security practices and procedures related to GitHub Actions within your organization.


------------------------------------------------------------------------
Q. How do you store credentials in GitHub securely?
-> GitHub Secrets is a built-in feature for storing sensitive information like API keys, passwords, and other credentials that your workflows or applications need. 
-> Secrets are encrypted and can be used in GitHub Actions workflows without exposing them in the code.

Go to Settings > Secrets and variables > Actions
1. Repository Secrets:: Click New repository secret
2. Organization Secrets:: New organization secret
3. Environment Secrets:: Settings > Environments  :: Add secret under the environmentâ€™s secrets section

1. Actions secrets and variables
-> Secrets and variables allow you to manage reusable configuration data. Secrets are encrypted and are used for sensitive data.
-> Variables are shown as plain text and are used for non-sensitive data.
-> Anyone with collaborator access to this repository can use these secrets and variables for actions. 
-> They are not passed to workflows that are triggered by a pull request from a fork.

2. Codespaces secrets: Development environment secrets are environment variables that are encrypted. Secrets are not passed to forks.

3. Dependabot secrets: Secrets are credentials that are encrypted. Anyone with collaborator access to this repository can use these secrets for Dependabot.
-> Secrets are not passed to forks.

---------------------------------------------------------------------------
3. What are the common use cases GitHub actions is used for?
-> Jenkins being open-source automation can be used for any kind of software-based
    automation. Some of the common use-cases include but not limited to -
* Software build jobs
* Sanity/Smoke/CI/Regression test jobs
* Web/Data Scraping related jobs
* Code coverage measurement jobs
* General-purpose automation
* Reverse Engineering jobs
* Key Decoding jobs & many other jobs where software automation will be applicable.

---------------------------------------------------------------------------
5. What is a GitHub Actions job?
-> In GitHub Actions, a job is a fundamental unit of work in a workflow. 
-> Jobs define a series of steps that are executed in a specific order, and they can be used to perform tasks such as building code, running tests, or deploying applications. 
-> Each job runs on a specific runner and can have its own environment and configuration.

-- Job Execution
Sequential vs. Parallel Execution: 
-- By default, jobs in a workflow run in parallel. However, you can control the order of execution by specifying dependencies using the "needs" keyword. 
-- Jobs that do not depend on each other will run simultaneously, while jobs that have dependencies will wait for the required jobs to complete before starting.

-- Job Configuration Options
Jobs have additional configuration options for more advanced use cases:

1. timeout-minutes: Set a timeout for how long a job is allowed to run before being automatically canceled.
timeout-minutes: 30

2. container: Run jobs inside a Docker container.
container:
  image: node:14

3. strategy: Configure matrix builds to run jobs with different configurations (e.g., different Node.js versions).
strategy:
  matrix:
    node-version: [12, 14, 16]


---------------------------------------------------------------------------
** Name some of the plugin used in GitHub actions and how to install it?
-- In GitHub Actions, plugins are referred to as "actions." Actions are reusable pieces of code that perform a specific task or set of tasks within a workflow. 
-- These actions can be created and shared by the community or developed by your team. Here are some commonly used GitHub Actions, along with instructions on how to incorporate them into your workflows:

1. actions/checkout: Checks out your repository so that your workflow can access its contents.
- uses: actions/checkout@v3

2. actions/setup-node: Sets up a Node.js environment for use in your workflow
- uses: actions/setup-node@v3
  with:
    node-version: '14'

3. actions/setup-python: Sets up a Python environment for use in your workflow.
- uses: actions/setup-python@v3
  with:
    python-version: '3.8'

4. actions/cache: Caches dependencies and build outputs to speed up subsequent workflow runs.
- uses: actions/cache@v3
  with:
    path: |
      ~/.cache/pip
      ~/.cache/pypoetry
    key: ${{ runner.os }}-pip-${{ hashFiles('**/poetry.lock') }}
    restore-keys: |
      ${{ runner.os }}-pip-

5. actions/upload-artifact: Uploads artifacts from a workflow run (e.g., build outputs, logs).
- uses: actions/upload-artifact@v3
  with:
    name: build-artifact
    path: path/to/artifact

6. actions/download-artifact: Downloads artifacts from a workflow run.
- uses: actions/download-artifact@v3
  with:
    name: build-artifact

7. docker/build-push-action: Builds and pushes Docker images.
- uses: docker/build-push-action@v3
  with:
    context: .
    push: true
    tags: ${{ secrets.DOCKER_TAG }}

8. actions/github-script: Allows you to run JavaScript code directly in your workflow.
- uses: actions/github-script@v6
  with:
    script: |
      console.log('Hello, world!');

9. actions/stale: Automatically labels or closes stale issues and pull requests.
- uses: actions/stale@v6
  with:
    repo-token: ${{ secrets.GITHUB_TOKEN }}
    days-before-stale: 30
    days-before-close: 7
    stale-issue-label: 'stale'
    stale-pr-label: 'stale'

10. psf/black: Runs the Black code formatter for Python.
- name: Format Python code
  uses: psf/black@v23


---------------------------------------------------------------------------
Q. What are the credential types supported by Jenkins?
-- GitHub Actions supports various credential types for secure and flexible authentication, including:
1. GitHub Secrets: For storing sensitive information like API keys and passwords.
2. GitHub Tokens: For interacting with GitHub APIs.
3. Personal Access Tokens (PATs): For access with specific permissions.
4. OAuth Tokens: For third-party application authorization to access GitHub resources on behalf of a user.
5. Deploy Keys: For SSH access to repositories.
6. Service Account Credentials: For accessing external services for authenticating and authorizing access to cloud services or external systems.
7. Environment Variables: For passing configuration and runtime values.

------------------------------------------------------------------------------------------
Q. Branch Protection Policies vs. Rulesets:
-> Branch protection policies and rulesets both offer frameworks for implementing governance controls, but they cater to different needs:
1. Branch Protection Policies are specific to individual branches within a repository, allowing for granular control over how code is reviewed, tested, and merged. 
-> They are ideal for projects requiring specific safeguards on critical branches.

2. Rulesets, on the other hand, can be applied at a more macro level, such as across an entire organization or repository. They offer a broader, more standardized approach to governance that can be consistently applied. 

âœ… How to Set Up Branch Protection Rules?
ðŸ”¹ Steps to Enable Branch Protection Rules (GitHub UI)
1. Go to GitHub Repository â†’ Settings â†’ Branches.
2. Under Branch protection rules, click "Add Rule".
3. Enter the branch name (e.g., main or develop).
4. Select protection options (explained below).
5. Click "Save Changes".

âœ… Key Branch Protection Features
1. ðŸ”¹Require a pull request before merging
-- Prevents direct pushes to protected branches.
-- Requires peer reviews before merging.
-- You can enforce minimum approvals (e.g., 1-2 reviewers).

1.1 Require approvals: When enabled, pull requests targeting a matching branch require a number of approvals and no changes requested before they can be merged.
1.2 Dismiss stale pull request approvals when new commits are pushed: New reviewable commits pushed to a matching branch will dismiss pull request review approvals.
1.3 Require review from Code Owners: Require an approved review in pull requests including files with a designated code owner.
1.4 Require approval of the most recent reviewable push: Whether the most recent reviewable push must be approved by someone other than the person who pushed it.


2. ðŸ”¹Require Status Checks to Pass Before Merging
-- Ensures that CI/CD pipelines (GitHub Actions, Jenkins, etc.) pass before merging.
-- Prevents merging if tests fail.

protection:
  required_status_checks:
    contexts: ["CI Tests", "Lint Check"]
    strict: true
2.1 Require branches to be up to date before merging: This ensures pull requests targeting a matching branch have been tested with the latest code. 
-- This setting will not take effect unless at least one status check is enabled (see below).


3. ðŸ”¹Require conversation resolution before merging
-- When enabled, all conversations on code must be resolved before a pull request can be merged into a branch that matches this rule.

4. ðŸ”¹Require Signed Commits
-- Ensures all commits are cryptographically signed to verify authorship.
protection:
  required_signatures: true

5. ðŸ”¹Require linear history
-- Prevent merge commits from being pushed to matching branches.
-- Enforces clean commit history by disallowing merge commits (only rebase or squash allowed).
protection:
  required_linear_history: true

6. ðŸ”¹Require deployments to succeed before merging
-- Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule.

7. ðŸ”¹Lock branch
-- Branch is read-only. Users cannot push to the branch.
-- Completely locks a branch from any modifications unless rules are changed.
protection:
  locked: true

8. Do not allow bypassing the above settings
-- The above settings will apply to administrators and custom roles with the "bypass branch protections" permission.

9. ðŸ”¹Restrict Who Can Push to Branches
-- Limits push access to specific users, teams, or bots.

protection:
  restrictions:
    users: ["admin-user"]
    teams: ["dev-team"]
    apps: ["github-actions"]


10. ðŸ”¹Prevent Force Pushes and Deletions
-- Blocks force pushes (git push --force) to prevent accidental or malicious code overwrites.
-- Prevents deletion of protected branches.

protection:
  enforce_admins: true
  allow_force_pushes: false
  allow_deletions: false


========================================================================================
Rules applied to everyone including administrators

1. ðŸ”¹Allow force pushes: Permit force pushes for all users with push access.
1.1 Everyone: Permit force pushes for all users with push access
1.2 Specify who can force push: Only these people, teams, or apps are allowed to force push.

2. ðŸ”¹Allow deletions: Allow users with push access to delete matching branches.


========================================================================================
âœ… Enforcing Branch Protection Rules via GitHub API (REST & GraphQL)
ðŸ”¹ Using GitHub REST API to Protect main Branch
curl -X PUT -H "Authorization: token GITHUB_TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    https://api.github.com/repos/OWNER/REPO/branches/main/protection \
    -d '{
      "required_status_checks": {
        "strict": true,
        "contexts": ["CI Tests", "Lint Check"]
      },
      "enforce_admins": true,
      "required_pull_request_reviews": {
        "dismiss_stale_reviews": true,
        "require_code_owner_reviews": true,
        "required_approving_review_count": 2
      },
      "restrictions": null
    }'

========================================================================================
** Best Practices for GitHub Branch Protection
âœ… Enable at least 1 required PR review to prevent bad code merges.
âœ… Require status checks to ensure CI/CD pipelines pass before merging.
âœ… Restrict force pushes and branch deletions for production branches.
âœ… Use code owner approvals for enforcing expertise-based reviews.
âœ… Use required signed commits to verify authenticity of commits.

========================================================================================

Rulesets: 
==========
-> Rulesets define whether collaborators can delete or force push and set requirements for any pushes, such as passing status checks or a linear commit history.

** GitHub Rulesets provide advanced repository-wide governance by enforcing:
-> Branch & Tag Protection: Restrict changes to multiple branches/tags at scale.
-> Pull Request Policies: Require approvals, status checks, or linear history before merging.
-> Commit Restrictions: Block force pushes, deletions, and unauthorized commits.
-> Access Controls: Restrict rules to specific teams, actors, or repository roles.
-> Enforcement Scope: Apply rules across multiple repositories, ensuring consistency. ðŸš€


Branch Protection vs. Rulesets in GitHub
========================================
1. Scope: Branch Protection applies to a specific branch (e.g., main, develop), while Rulesets apply to multiple branches and repositories.
2. Granularity: Branch Protection enforces basic restrictions (reviews, status checks, merge rules), whereas Rulesets offer advanced, customizable rules across repositories.
3. Flexibility: Branch Protection is limited to predefined settings per branch, but Rulesets allow broader policies for branches, PRs, and repositories.
4. Use Case: Branch Protection ensures security and consistency on key branches, while Rulesets define governance policies at scale.
5. Example: Branch Protection requires 2 approvals before merging into main, while Rulesets block force pushes across all feature/* branches. ðŸš€















